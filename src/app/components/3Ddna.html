<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>סליל DNA מסתובב</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Basic body settings */
        body {
            margin: 0;
            overflow: hidden; /* Prevents scrolling */
            font-family: 'Inter', sans-serif; /* Using Inter font */
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text color */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        /* Three.js canvas settings */
        canvas {
            display: block; /* Prevents extra space below canvas */
            width: 100%;
            height: 100%;
        }

        /* Container for title and canvas */
        #container {
            width: 95%; /* Responsive width */
            max-width: 800px; /* Maximum width */
            height: 70vh; /* Relative height to viewport */
            background-color: #2d3748; /* Darker background for container */
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3); /* Subtle shadow */
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Application title */
        h1 {
            font-size: 2.5rem; /* Large title size */
            font-weight: bold;
            margin-bottom: 1.5rem; /* Bottom margin */
            color: #63b3ed; /* Light blue color for title */
            text-align: center;
        }

        /* Loading message */
        #loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #a0aec0;
            font-size: 1.2rem;
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4">
    <h1 class="text-blue-400 text-4xl font-bold mb-6 text-center">סליל DNA מסתובב בחלל</h1>
    <div id="container" class="relative w-full max-w-4xl h-96 bg-gray-800 rounded-2xl shadow-lg flex items-center justify-center">
        <div id="loading-message">טוען סליל DNA...</div>
        </div>

    <script>
        // Global variables for scene, camera, and renderer
        let scene, camera, renderer, controls;
        let dnaGroup; // Group to hold all DNA parts

        // Function to initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c); // Dark background for scene

            // Create camera
            // PerspectiveCamera(FOV, Aspect Ratio, Near, Far)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50; // Camera position

            // Create WebGL renderer
            renderer = new THREE.WebGLRenderer({ antialias: true }); // antialias for smoother graphics
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Add the renderer's canvas to the HTML container
            const container = document.getElementById('container');
            container.appendChild(renderer.domElement);

            // Hide loading message after canvas is ready
            document.getElementById('loading-message').style.display = 'none';

            // Add OrbitControls
            // Allows user to rotate, zoom in and out with mouse/touch
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smoother animation
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Prevents panning in screen space
            controls.minDistance = 20; // Minimum zoom distance
            controls.maxDistance = 100; // Maximum zoom distance

            // Add lighting
            // Directional light simulating sunlight
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Subtle ambient light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // Create a group for the entire DNA helix
            dnaGroup = new THREE.Group();
            scene.add(dnaGroup);

            // Build the DNA helix
            createDNAHelix();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Function to handle window resize
        function onWindowResize() {
            const container = document.getElementById('container');
            // Update camera aspect ratio and renderer size
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Function to create the DNA helix
        function createDNAHelix() {
            const helixHeight = 60; // Height of the helix
            const radius = 5; // Radius of the helix
            const turns = 10; // Number of turns in the helix
            const basePairSpacing = 1.5; // Vertical spacing between base pairs
            const segmentsPerTurn = 12; // Number of base pairs per full turn (approx 10-10.5 in real DNA)
            const totalSegments = turns * segmentsPerTurn; // Total number of base pairs

            const sphereRadius = 0.8; // Radius of the spheres (nucleotides)
            const backboneCylinderRadius = 0.3; // Radius of the backbone cylinders
            const basePairCylinderRadius = 0.2; // Radius of the cylinders connecting base pairs

            // Colors for the four nucleotide bases
            const baseColors = {
                A: new THREE.Color(0xff0000), // Adenine (Red)
                T: new THREE.Color(0x00ff00), // Thymine (Green)
                G: new THREE.Color(0x0000ff), // Guanine (Blue)
                C: new THREE.Color(0xffff00)  // Cytosine (Yellow)
            };

            const backboneColor = new THREE.Color(0x888888); // Gray for sugar-phosphate backbone
            const hydrogenBondColor = new THREE.Color(0xaaaaaa); // Light gray for hydrogen bonds

            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
            const backboneCylinderGeometry = new THREE.CylinderGeometry(backboneCylinderRadius, backboneCylinderRadius, 1, 8);
            const basePairCylinderGeometry = new THREE.CylinderGeometry(basePairCylinderRadius, basePairCylinderRadius, 1, 8);

            let prevPoint1 = null;
            let prevPoint2 = null;
            let prevBackbonePoint1 = null;
            let prevBackbonePoint2 = null;

            // Define base pairing rules
            const basePairs = [
                ['A', 'T'],
                ['T', 'A'],
                ['G', 'C'],
                ['C', 'G']
            ];

            for (let i = 0; i <= totalSegments; i++) {
                const angle = (i / segmentsPerTurn) * Math.PI * 2; // Angle for the current segment
                const y = (i - totalSegments / 2) * basePairSpacing; // Y position along the helix

                // Points for the two strands of the DNA
                const x1 = radius * Math.cos(angle);
                const z1 = radius * Math.sin(angle);
                const point1 = new THREE.Vector3(x1, y, z1);

                const x2 = radius * Math.cos(angle + Math.PI); // Second strand is offset by PI
                const z2 = radius * Math.sin(angle + Math.PI);
                const point2 = new THREE.Vector3(x2, y, z2);

                // Randomly select a base pair
                const [base1Type, base2Type] = basePairs[Math.floor(Math.random() * basePairs.length)];

                // Create spheres for nucleotides (bases)
                const sphere1 = new THREE.Mesh(sphereGeometry, new THREE.MeshPhongMaterial({ color: baseColors[base1Type] }));
                sphere1.position.copy(point1);
                dnaGroup.add(sphere1);

                const sphere2 = new THREE.Mesh(sphereGeometry, new THREE.MeshPhongMaterial({ color: baseColors[base2Type] }));
                sphere2.position.copy(point2);
                dnaGroup.add(sphere2);

                // Create cylinders for hydrogen bonds between base pairs
                const baseLink = createCylinderMesh(point1, point2, basePairCylinderRadius, new THREE.MeshPhongMaterial({ color: hydrogenBondColor }));
                dnaGroup.add(baseLink);

                // Create backbone cylinders (sugar-phosphate)
                // These connect the nucleotides along each strand
                if (prevPoint1 && prevPoint2) {
                    const backbone1 = createCylinderMesh(prevPoint1, point1, backboneCylinderRadius, new THREE.MeshPhongMaterial({ color: backboneColor }));
                    dnaGroup.add(backbone1);

                    const backbone2 = createCylinderMesh(prevPoint2, point2, backboneCylinderRadius, new THREE.MeshPhongMaterial({ color: backboneColor }));
                    dnaGroup.add(backbone2);
                }

                prevPoint1 = point1;
                prevPoint2 = point2;
            }
        }

        // Helper function to create a cylinder mesh between two points
        function createCylinderMesh(point1, point2, radius, material) {
            const direction = new THREE.Vector3().subVectors(point2, point1);
            const length = direction.length();
            const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 8), material);
            cylinder.position.copy(new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5));
            cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
            return cylinder;
        }

        // Animation function
        function animate() {
            requestAnimationFrame(animate); // Request next frame

            // Rotate the DNA group
            if (dnaGroup) {
                dnaGroup.rotation.y += 0.005; // Slow rotation around Y-axis
            }

            controls.update(); // Update controls (important for enableDamping)
            renderer.render(scene, camera); // Render the scene
        }

        // Run initialization and animation after window loads
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
